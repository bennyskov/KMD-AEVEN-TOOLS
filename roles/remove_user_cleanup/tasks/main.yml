---
# Main tasks file for remove_user_cleanup role

- name: 'Check if {{ username }} already exists'
  shell: 'id {{ username }}'
  register: user_info
  changed_when: false
  failed_when: false

- name: "Process user cleanup for {{ username }}"
  when: user_info.rc == 0
  block:
    - name: "Kill all processes owned by {{ username }}"
      shell: "pkill -9 -u {{ username }} || true"
      ignore_errors: true

    - name: "Remove mail spool for {{ username }}"
      file:
        path: "/var/mail/{{ username }}"
        state: absent
      ignore_errors: true

    - name: "Remove temp files for {{ username }}"
      shell: "find /tmp -user {{ username }} -exec rm -rf {} \\; 2>/dev/null || true"
      ignore_errors: true

    - name: "Remove cron jobs for {{ username }}"
      file:
        path: "/var/spool/cron/{{ username }}"
        state: absent
      ignore_errors: true

    - name: "Remove print jobs for {{ username }}"
      shell: "find /var/spool/cups -user {{ username }} -exec rm -rf {} \\; 2>/dev/null || true"
      ignore_errors: true

    - name: "Delete user {{ username }}"
      user:
        name: "{{ username }}"
        remove: "{{ remove_home }}"
        state: absent
      ignore_errors: true
      register: delete_user_result

    - name: "Delete sudoers profile for {{ username }}"
      file:
        path: "{{ sudoers_path }}"
        state: absent
      ignore_errors: true

    - name: "Delete home directory for {{ username }} if it still exists"
      file:
        path: "{{ user_home | default('/home/' + username) }}"
        state: absent
        force: "{{ force_removal }}"
      ignore_errors: true

    - name: "Remove any other sudoers files for {{ username }}"
      shell: "find /etc/sudoers.d/ -name '*{{ username }}*' -exec rm -f {} \\; 2>/dev/null || true"
      ignore_errors: true

    # Advanced process handling section (from ITM uninstall script)
    - name: "Handle locked processes for {{ username }}"
      when:
        - handle_locked_processes | bool
        - delete_user_result is defined
        - delete_user_result.failed is defined
        - delete_user_result.failed
      block:
        - name: "Parse process ID when user deletion fails"
          set_fact:
            process_id: "{{ (delete_user_result.msg | regex_findall('process ([0-9]+)')) | first | default('') }}"
          when:
            - delete_user_result.msg is defined
            - delete_user_result.msg is search("user " + username + " is currently used by process")

        - name: "Show process information that is locking the user"
          shell: "ps -p {{ process_id }} -o pid,ppid,user,cmd,etime"
          register: process_info
          ignore_errors: yes
          when: process_id is defined and process_id != ''

        - name: "Verify locking process command contains application path (if specified)"
          set_fact:
            locking_process_check: "{{ process_info.stdout is defined and application_path_check in process_info.stdout }}"
          when:
            - process_id is defined and process_id != ''
            - process_info is defined
            - application_path_check != ""

        - name: "Display verification result for application path"
          debug:
            msg: "Locking process {{ process_id }} command contains '{{ application_path_check }}': {{ locking_process_check }}"
          when:
            - process_id is defined and process_id != ''
            - locking_process_check is defined

        - name: "Display process information"
          debug:
            var: process_info.stdout_lines
          when: process_id is defined and process_id != ''

        - name: "Get all processes running as {{ username }}"
          shell: "ps -u {{ username }} -o pid,ppid,user,cmd,etime"
          register: user_processes
          ignore_errors: yes
          when:
            - delete_user_result.msg is defined
            - delete_user_result.msg is search("user " + username + " is currently used by process")

        - name: "Display all {{ username }} processes"
          debug:
            var: user_processes.stdout_lines
          when:
            - user_processes is defined
            - user_processes.stdout_lines is defined

        - name: "Kill locking process (if found)"
          shell: "kill -9 {{ process_id }}"
          register: kill_process_result
          ignore_errors: yes
          when:
            - process_id is defined
            - process_id != ''

        - name: "Retry delete user {{ username }} after killing process"
          user:
            name: "{{ username }}"
            remove: "{{ remove_home }}"
            state: absent
          register: retry_delete_user_result
          ignore_errors: true
          when:
            - process_id is defined
            - process_id != ''

        - name: "Show result of retry delete user"
          debug:
            var: retry_delete_user_result
          when:
            - retry_delete_user_result is defined

    # Check for remaining files after cleanup
    - name: "Check for remaining files owned by {{ username }}"
      shell: "find / -user {{ username }} -ls 2>/dev/null || true"
      register: remaining_files
      ignore_errors: true
      changed_when: false
      when: check_remaining_files | bool

    - name: "Display any remaining files"
      debug:
        msg: "Remaining files for {{ username }}: {{ remaining_files.stdout_lines }}"
      when:
        - check_remaining_files | bool
        - remaining_files is defined
        - remaining_files.stdout_lines is defined
        - remaining_files.stdout_lines | length > 0
