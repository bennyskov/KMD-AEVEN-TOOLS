# Enhanced Windows verification playbook with automatic inventory detection and host-specific credentials
# Supports both single host and inventory-wide execution with intelligent inventory suggestions
# Uses Tower/AWX API to search across all 4 customer inventories when host not found locally

- name: Pre-flight validation and inventory detection
  hosts: localhost
  gather_facts: false
  vars:
    # Define the 4 customer inventories to search
    customer_inventories:
      - name: "kmn_inventory"
        org: "kmn"
        description: "KMN customers"
      - name: "kmw_inventory"
        org: "kmw"
        description: "KMW customers (includes ebok hosts)"
      - name: "eng_inventory"
        org: "eng"
        description: "Energinet customers"
      - name: "eng_HEM"
        org: "eng"
        description: "HEM/Energinet customers"
  tasks:
    - name: Determine execution mode
      set_fact:
        single_host_mode: "{{ nodename is defined }}"
        execution_mode: "{{ 'Single Host' if nodename is defined else 'Inventory Wide' }}"

    - name: Display execution mode and context
      debug:
        msg: |
          🎯 EXECUTION MODE: {{ execution_mode }}
          Target: {{ nodename | default('All Windows hosts in current inventory') }}
          Current inventory size: {{ groups['all'] | default([]) | length }} hosts
          Playbook will automatically detect organization and assign appropriate credentials

    - name: Validate single host execution
      block:
        - name: Check if host exists in current inventory
          set_fact:
            host_in_current_inventory: "{{ nodename in (groups['all'] | default([])) }}"

        - name: Display host validation status
          debug:
            msg: |
              🔍 HOST VALIDATION:
              Requested host: {{ nodename }}
              Host exists in current inventory: {{ host_in_current_inventory }}
              {% if not host_in_current_inventory %}

              ⚠️  Will search across all customer inventories using Tower/AWX API...
              {% endif %}

        - name: Search across all customer inventories if host not found locally
          block:
            - name: Initialize search variables
              set_fact:
                found_inventories: []
                search_results: []

            - name: Search for host in each customer inventory via Tower/AWX API
              uri:
                url: "{{ tower_host | default(ansible_tower_host) }}/api/v2/inventories/{{ item.name }}/hosts/?search={{ nodename }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ tower_token | default(ansible_tower_token) }}"
                validate_certs: false
                status_code: [200, 401, 403, 404]
              register: inventory_search_result
              ignore_errors: yes
              loop: "{{ customer_inventories }}"
              when:
                - tower_host is defined or ansible_tower_host is defined
                - tower_token is defined or ansible_tower_token is defined

            - name: Process search results to identify matching inventories
              set_fact:
                found_inventories: "{{ found_inventories + [{'inventory': item.item.name, 'org': item.item.org, 'description': item.item.description}] }}"
              loop: "{{ inventory_search_result.results | default([]) }}"
              when:
                - item.status is defined
                - item.status == 200
                - item.json is defined
                - item.json.count is defined
                - item.json.count > 0

            - name: Set primary organization from search results
              set_fact:
                detected_org: "{{ found_inventories[0].org }}"
                recommended_inventory: "{{ found_inventories[0].inventory }}"
              when: found_inventories | length > 0

            - name: Display comprehensive search results
              debug:
                msg: |
                  📊 INVENTORY SEARCH RESULTS for '{{ nodename }}':

                  {% if found_inventories | length > 0 %}
                  ✅ HOST FOUND IN: {{ found_inventories | map(attribute='inventory') | join(', ') }}

                  🎯 RECOMMENDED ACTION:
                  Re-run this job template with inventory: {{ recommended_inventory }}
                  Organization: {{ detected_org | upper }}

                  💡 Additional matches: {{ found_inventories[1:] | map(attribute='inventory') | join(', ') if found_inventories | length > 1 else 'none' }}
                  {% else %}
                  ❌ HOST NOT FOUND in any customer inventory:
                     {% for inv in customer_inventories %}
                     - {{ inv.name }} ({{ inv.description }})
                     {% endfor %}

                  🔍 POSSIBLE CAUSES:
                  1. Hostname spelling error: '{{ nodename }}'
                  2. Host not yet added to Tower/AWX
                  3. Host exists in a different (non-customer) inventory
                  4. API authentication issues

                  🚀 TROUBLESHOOTING STEPS:
                  1. Verify hostname spelling: '{{ nodename }}'
                  2. Check Tower/AWX web interface manually
                  3. Verify host exists in target environment
                  4. Try each inventory manually: {{ customer_inventories | map(attribute='name') | join(', ') }}
                  {% endif %}

            - name: Set execution guidance
              set_fact:
                inventory_search_completed: true
                should_continue_execution: "{{ host_in_current_inventory or found_inventories | length > 0 }}"

          when: not host_in_current_inventory

        - name: Display success when host found locally
          debug:
            msg: "✅ Host '{{ nodename }}' found in current inventory. Proceeding with verification."
          when: host_in_current_inventory

      when: single_host_mode

    - name: Display inventory-wide mode confirmation
      debug:
        msg: |
          📊 INVENTORY-WIDE EXECUTION MODE
          Will process all Windows hosts in current inventory
          Total hosts to evaluate: {{ groups['all'] | default([]) | length }}
          Non-Windows hosts will be automatically skipped
          Each host will have organization auto-detected and appropriate credentials assigned
      when: not single_host_mode

- name: Socks tunnel setup
  hosts: localhost
  gather_facts: false
  tasks:
    - include_role:
        name: ansible-role-event-socks-tunnel
        apply:
          check_mode: false
          run_once: true
          delegate_to: localhost

- name: Windows host verification with dynamic credentials
  hosts: "{{ nodename | default('all') }}"
  gather_facts: true
  ignore_unreachable: true
  ignore_errors: true
  vars:
    # Organization to credential mapping
    org_credential_patterns:
      kmn:
        os_user: "kmn_cred_{{ inventory_hostname }}_cyberark_user"
        os_password: "kmn_cred_{{ inventory_hostname }}_cyberark_password"
        jumphost_user: "kmn_cred_{{ inventory_hostname }}_sshproxy_user"
        jumphost_password: "kmn_cred_{{ inventory_hostname }}_sshproxy_password"
      kmw:
        os_user: "kmw_cred_{{ inventory_hostname }}_cyberark_user"
        os_password: "kmw_cred_{{ inventory_hostname }}_cyberark_password"
        jumphost_user: "kmw_cred_{{ inventory_hostname }}_sshproxy_user"
        jumphost_password: "kmw_cred_{{ inventory_hostname }}_sshproxy_password"
      eng:
        os_user: "eng_cred_{{ inventory_hostname }}_cyberark_user"
        os_password: "eng_cred_{{ inventory_hostname }}_cyberark_password"
        jumphost_user: "eng_cred_{{ inventory_hostname }}_sshproxy_user"
        jumphost_password: "eng_cred_{{ inventory_hostname }}_sshproxy_password"
  tasks:
    - name: Display processing status
      debug:
        msg: |
          === PROCESSING HOST: {{ inventory_hostname }} ===
          Mode: {{ 'Single Host' if nodename is defined else 'Inventory Wide' }}
          Target: {{ nodename | default('All Windows hosts in inventory') }}

    - name: Skip non-Windows hosts in inventory-wide mode
      block:
        - name: Check OS family
          debug:
            msg: "Host {{ inventory_hostname }} OS: {{ ansible_facts['os_family'] | default('Unknown') }}"

        - name: Skip if not Windows (inventory-wide mode only)
          meta: end_host
          when:
            - nodename is not defined  # Only skip in inventory-wide mode
            - ansible_facts['os_family'] is not defined or ansible_facts['os_family'] != 'Windows'

        - name: Confirm Windows host
          debug:
            msg: "✅ Processing Windows host: {{ inventory_hostname }}"
          when: ansible_facts['os_family'] is defined and ansible_facts['os_family'] == 'Windows'

    - name: Validate single host target
      block:
        - name: Check nodename match
          debug:
            msg: "Verifying {{ inventory_hostname }} matches target: {{ nodename }}"

        - name: Skip if not matching target host
          meta: end_host
          when:
            - nodename is defined
            - inventory_hostname != nodename
            - inventory_hostname not in (nodename.split(',') if ',' in nodename else [])

        - name: Confirm target match
          debug:
            msg: "✅ Host {{ inventory_hostname }} matches target: {{ nodename }}"
          when:
            - nodename is defined
            - (inventory_hostname == nodename or inventory_hostname in (nodename.split(',') if ',' in nodename else []))

      when: nodename is defined

    - name: Auto-detect organization from hostname patterns
      set_fact:
        detected_org: >-
          {%- if inventory_hostname | lower is match('^kmn.*') -%}
            kmn
          {%- elif inventory_hostname | lower is match('^kmw.*') or 'ebok' in inventory_hostname | lower -%}
            kmw
          {%- elif inventory_hostname | lower is match('^eng.*') -%}
            eng
          {%- elif inventory_hostname | lower is match('^hem.*') or 'energinet' in inventory_hostname | lower -%}
            eng
          {%- else -%}
            kmw
          {%- endif -%}
        detected_inventory: >-
          {%- if inventory_hostname | lower is match('^kmn.*') -%}
            kmn_inventory
          {%- elif inventory_hostname | lower is match('^kmw.*') or 'ebok' in inventory_hostname | lower -%}
            kmw_inventory
          {%- elif inventory_hostname | lower is match('^eng.*') -%}
            eng_inventory
          {%- elif inventory_hostname | lower is match('^hem.*') or 'energinet' in inventory_hostname | lower -%}
            eng_HEM
          {%- else -%}
            kmw_inventory
          {%- endif -%}

    - name: Display detection results
      debug:
        msg: |
          🔍 AUTO-DETECTION RESULTS:
          Host: {{ inventory_hostname }}
          Detected Organization: {{ detected_org | upper }}
          Detected Inventory: {{ detected_inventory }}
          Will use credential pattern: {{ detected_org }}_cred_{{ inventory_hostname }}_*

    - name: Lookup host-specific OS credentials
      set_fact:
        ansible_user: "{{ lookup('cyberark', org_credential_patterns[detected_org].os_user, errors='ignore') }}"
        ansible_password: "{{ lookup('cyberark', org_credential_patterns[detected_org].os_password, errors='ignore') }}"
        credential_source: "host_specific_os"
      when: detected_org in org_credential_patterns
      no_log: true
      ignore_errors: yes

    - name: Lookup host-specific jumphost credentials
      set_fact:
        jumphost_user: "{{ lookup('cyberark', org_credential_patterns[detected_org].jumphost_user, errors='ignore') }}"
        jumphost_password: "{{ lookup('cyberark', org_credential_patterns[detected_org].jumphost_password, errors='ignore') }}"
        jumphost_credential_source: "host_specific_jumphost"
      when: detected_org in org_credential_patterns
      no_log: true
      ignore_errors: yes

    - name: Display credential lookup status
      debug:
        msg: |
          🔐 CREDENTIAL LOOKUP STATUS:
          Organization: {{ detected_org | upper }}
          OS Credentials: {{ 'Found' if ansible_user is defined and ansible_user != '' else 'Not Found' }}
          Jumphost Credentials: {{ 'Found' if jumphost_user is defined and jumphost_user != '' else 'Not Found' }}
          Credential Patterns:
          - OS: {{ org_credential_patterns[detected_org].os_user if detected_org in org_credential_patterns else 'N/A' }}
          - Jumphost: {{ org_credential_patterns[detected_org].jumphost_user if detected_org in org_credential_patterns else 'N/A' }}

    - name: Handle missing credentials gracefully
      block:
        - name: Display credential warning
          debug:
            msg: |
              ⚠️  CREDENTIAL WARNING for {{ inventory_hostname }}:

              OS credentials not found for pattern: {{ org_credential_patterns[detected_org].os_user if detected_org in org_credential_patterns else 'N/A' }}

              🔍 POSSIBLE CAUSES:
              1. Host-specific credentials not yet configured in CyberArk
              2. Incorrect organization detection (detected: {{ detected_org | upper }})
              3. Non-standard credential naming pattern

              🚀 RECOMMENDED ACTIONS:
              1. Verify organization: {{ detected_org | upper }}
              2. Check CyberArk for: {{ detected_org }}_cred_{{ inventory_hostname }}_cyberark_*
              3. Ensure credentials are properly configured
              4. Try running with correct inventory: {{ detected_inventory }}

        - name: Skip host without credentials
          meta: end_host

      when: ansible_user is not defined or ansible_user == ''

    - name: Test connection with assigned credentials
      win_ping:
      ignore_errors: yes
      register: connection_test

    - name: Display connection status
      debug:
        msg: |
          🔌 CONNECTION TEST RESULTS:
          Host: {{ inventory_hostname }}
          Organization: {{ detected_org | upper }}
          Inventory: {{ detected_inventory }}
          Status: {{ 'SUCCESS' if connection_test is succeeded else 'FAILED' }}
          {% if connection_test is failed %}
          Error: {{ connection_test.msg | default('Connection failed') }}
          {% endif %}

    - name: Handle connection failure gracefully
      block:
        - name: Display connection failure guidance
          debug:
            msg: |
              ❌ CONNECTION FAILED to {{ inventory_hostname }}:

              🔍 POSSIBLE CAUSES:
              1. Incorrect credentials for organization: {{ detected_org | upper }}
              2. Host not accessible from current network/jumphost
              3. Windows Remote Management (WinRM) not configured
              4. Firewall blocking connection

              🚀 TROUBLESHOOTING STEPS:
              1. Verify host is accessible: {{ inventory_hostname }}
              2. Check organization detection: {{ detected_org | upper }}
              3. Verify credentials in CyberArk: {{ detected_org }}_cred_{{ inventory_hostname }}_*
              4. Ensure correct inventory: {{ detected_inventory }}

        - name: Skip host with failed connection
          meta: end_host

      when: connection_test is failed

    # Proceed with de-tooling verification for successfully connected hosts
    - name: Verify ITM installation directories cleared
      win_shell: (Test-Path "C:/IBM/ITM/bin") -and ((Get-ChildItem -Path "C:/IBM/ITM" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_itm_files

    - name: Verify Opsware installation directories cleared
      win_shell: (Test-Path "C:/Program Files/Opsware/agent/bin") -and ((Get-ChildItem -Path "C:/Program Files/Opsware/agent/bin" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_opsware_files

    - name: Check ITM services status
      win_shell: "[bool](Get-Service KNT*, K06* -ErrorAction SilentlyContinue)"
      ignore_errors: yes
      register: get_service_itm

    - name: Check Opsware services status
      win_shell: "[bool](Get-Service opsware* -ErrorAction SilentlyContinue)"
      ignore_errors: yes
      register: get_service_SA

    - name: Test if ansible workdir has been cleared
      win_shell: (Test-Path "C:/ansible_workdir") -and ((Get-ChildItem -Path "C:/ansible_workdir" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_ansible_workdir

    - name: Test if ansible ProgramData has been cleared
      win_shell: (Test-Path "C:/ProgramData/ansible") -and ((Get-ChildItem -Path "C:/ProgramData/ansible" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_ansible_programdata

    - name: Test if BigFix ProgramData has been cleared
      win_shell: (Test-Path "C:/ProgramData/BigFix") -and ((Get-ChildItem -Path "C:/ProgramData/BigFix" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_bigfix_programdata

    - name: Test if ilmt ProgramData has been cleared
      win_shell: (Test-Path "C:/ProgramData/ilmt") -and ((Get-ChildItem -Path "C:/ProgramData/ilmt" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_ilmt_programdata

    - name: Test if ansible Program Files has been cleared
      win_shell: (Test-Path "C:/PROGRA~1/ansible") -and ((Get-ChildItem -Path "C:/PROGRA~1/ansible" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_ansible_progfiles

    - name: Test if BigFix Program Files has been cleared
      win_shell: (Test-Path "C:/PROGRA~1/BigFix") -and ((Get-ChildItem -Path "C:/PROGRA~1/BigFix" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_bigfix_progfiles

    - name: Test if ilmt Program Files has been cleared
      win_shell: (Test-Path "C:/PROGRA~1/ilmt") -and ((Get-ChildItem -Path "C:/PROGRA~1/ilmt" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0)
      ignore_errors: yes
      register: check_ilmt_progfiles

    - name: Determine cleanup status
      set_fact:
        itm_cleanup_needed: "{{ check_itm_files.stdout == 'True' }}"
        opsware_cleanup_needed: "{{ check_opsware_files.stdout == 'True' }}"
        ansible_cleanup_needed: "{{ (check_ansible_workdir.stdout == 'True') or (check_ansible_programdata.stdout == 'True') or (check_ansible_progfiles.stdout == 'True') }}"
        bigfix_cleanup_needed: "{{ (check_bigfix_programdata.stdout == 'True') or (check_bigfix_progfiles.stdout == 'True') }}"
        ilmt_cleanup_needed: "{{ (check_ilmt_programdata.stdout == 'True') or (check_ilmt_progfiles.stdout == 'True') }}"

    - name: Display final verification summary
      debug:
        msg: |
          ╔══════════════════════════════════════════════════════════════════════════════════════╗
          ║                          DE-TOOLING VERIFICATION SUMMARY                             ║
          ╠══════════════════════════════════════════════════════════════════════════════════════╣
          ║ Host: {{ "%-76s" | format(inventory_hostname) }} ║
          ║ Organization: {{ "%-67s" | format(detected_org | upper) }} ║
          ║ Inventory: {{ "%-70s" | format(detected_inventory) }} ║
          ║ Execution Mode: {{ "%-65s" | format(execution_mode) }} ║
          ║ Connection: {{ "%-69s" | format('SUCCESS') }} ║
          ║ Credentials: {{ "%-68s" | format(credential_source | default('host_specific')) }} ║
          ╠══════════════════════════════════════════════════════════════════════════════════════╣
          ║                                CLEANUP STATUS                                        ║
          ╠══════════════════════════════════════════════════════════════════════════════════════╣
          ║ ITM Cleanup Required: {{ "%-59s" | format(itm_cleanup_needed | default('Unknown')) }} ║
          ║ Opsware Cleanup Required: {{ "%-55s" | format(opsware_cleanup_needed | default('Unknown')) }} ║
          ║ Ansible Cleanup Required: {{ "%-55s" | format(ansible_cleanup_needed | default('Unknown')) }} ║
          ║ BigFix Cleanup Required: {{ "%-56s" | format(bigfix_cleanup_needed | default('Unknown')) }} ║
          ║ ILMT Cleanup Required: {{ "%-58s" | format(ilmt_cleanup_needed | default('Unknown')) }} ║
          ╠══════════════════════════════════════════════════════════════════════════════════════╣
          ║ Overall Status: {{ "%-65s" | format('CLEANUP NEEDED' if (itm_cleanup_needed or opsware_cleanup_needed or ansible_cleanup_needed or bigfix_cleanup_needed or ilmt_cleanup_needed) else 'VERIFICATION PASSED') }} ║
          ╚══════════════════════════════════════════════════════════════════════════════════════╝